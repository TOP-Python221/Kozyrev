# ИСПРАВИТЬ: что такое "обычные атрибуты"?
"""Представление матрицы с обычными атрибутами"""

# ДОБАВИТЬ: документацию класса
class Matrix:
    # ИСПРАВИТЬ: название elem не отражает ожидаемое значения для параметра — вложенные списки
    # ДОБАВИТЬ: аннотацию типа параметра elem
    def __init__(self, elem):
        self.elem = elem
        # ДОБАВИТЬ: учитывая, сколько раз в дальнейшем вам будет необходимо вычислять длины строк и столбцов матрицы, я бы на вашем месте записал их в атрибуты ещё на этапе инициализации матрицы — размерности матрицы достаточно полезно знать для многих операций

    def __str__(self):
        # ИСПРАВИТЬ: так как вычисляемый объект используется только в данном методе, то нет необходимости сохранять эту строку в атрибут
        self.show_elem = '\n'.join([
            # ИСПРАВИТЬ: символ табуляции не всегда уместен (см. примеры ниже)
            '\t'.join([
                # ИСПОЛЬЗОВАТЬ: имена i, j, k мы используем для индексов, а здесь у вас элементы, а не их индексы
                str(n) for n in row
            ])
            for row in self.elem
        ])
        # ДОБАВИТЬ: очень хорошо, с простым выводом вы справились — теперь сделайте форматированный, с выравниванием столбцов матрицы (рекомендую опираться на код функции draw_boards() в репозитории _project1_reference)
        return self.show_elem

    def __add__(self, other):
        result = []
        for i in range(len(self.elem)):
            # ИСПОЛЬЗОВАТЬ: для локальной переменной мы вполне можем использовать заметно более быструю, чем метод append() конкатенацию списков
            result += [[]]
            for j in range(len(self.elem[i])):
                result[i] += [other.elem[i][j] + self.elem[i][j]]
                # КОММЕНТАРИЙ:
                #  1) вам не нужно изменять размерность результирующей матрицы (см. пример ниже);
                #  2) все проверки объекта other должны осуществляться до начала итераций;
                #  3) в этой задаче мы считаем, что все матрицы и операции корректные — проверки вводите в следующем задании на исключения
        return Matrix(result)

    # ИСПРАВИТЬ: аналогично предыдущему методу
    def __sub__(self, other_sub):
        result_sub = []
        numbers = []
        for i in range(len(self.elem)):
            for j in range(len(self.elem[i])):
                summa = other_sub.elem[i][j] - self.elem[i][j]
                numbers.append(summa)
                if len(numbers) == len(self.elem):
                    result_sub.append(numbers)
                    numbers = []
        return Matrix(result_sub)


g = [[1, 2, 3, 4], [5, 6, 7, 8], [1, 5, 3, 66]]
a = [[5, 25, 35, 45], [57, 66, 75, 84], [15, 56, 37, -24]]

m1 = Matrix(g)
m2 = Matrix(a)
m3 = m1 + m2
m4 = m2 - m1
print(m1, end='\n\n')
print(m2, end='\n\n')
print(m3, end='\n\n')
print(m4, end='\n\n')


# stdout:
# 1	2	3	4
# 5	6	7	8
# 1	5	3	66

# 5	25	35	45
# 57	66	75	84
# 15	56	37	-24

# КОММЕНТАРИЙ: вот здесь у вас меняется размерность матрицы
# 6	 27	38
# 49 62	72
# 82 92	16
# 61 40	42

# -4 -23 -32
# -41 -52 -60
# -68 -76 -14
# -51 -34 90


m5 = Matrix([[1, 2000, 3], [4, 5, 6], [7000, 8, 9]])
print(m5, end='\n\n')

# 1	2000	3
# 4	5	6
# 7000	8	9


# КОММЕНТАРИЙ: самое главное — разных способов хранения элементов матрицы не увидел.
#  можно для каждого элемента матрицы динамически создать свой атрибут, можно создать атрибуты rows и columns, можно хранить всю матрицу в одном атрибуте в виде словаря, можно создать отдельный(-ые) класс(-ы) для ряда и/или столбца и использовать экземпляры этого класса в классе матрицы...


# ИТОГ: неплохо, но стоит обратить внимание на много аспектов, и больше кода! — 7/12
